Java Collection Framework (JCF)의 이해
=======================

## 자바 컬렌션 프레임워크(JCF)란?
Java에서 데이터를 저장하는 기본적인 자료구조들을 한곳에 모아 관리 및 사용하기 위해서 제공하는 것을 의미한다.   
즉, 데이터를 담는 그릇들에 대한 정의를 모아놓은 프레임워크를 의미하며,    
값의 성격이나 용도에 따라, 활용방법에 따라 다양한 컨테이너를 제공한다.  
다음은 JCF의 상송 구조이며 사용 용도에 따라 List, Set, Map 3가지로 요약할 수 있다.
![jcf](../img/jcf.png)
   

## 각 인터페이스 별 특징
| **인터페이스** | **구현 class** | **특징** |
|:---:|:---:|:---:|
| List | ArrayList<br>Stack<br>Vector<br>LinkedList|순서가 있는 데이터의 집합으로,<br>데이터의 중복을 허용한다.|
| Set | HashSet<br>TreeSet | 순서를 유지하지 않는 데이터의 집합으로,<br>데이터의 중복을 허용하지 않는다. |
| Map | HashMap<br>TreeMap<br>HashTable | Key-Value쌍으로 이루어진 데이터의 집합으로,<br>키는 절대 중복이 불가하며 값은 중복을 허용할 수도 있다. |
   
     
### List Interface(순서 O, 데이터 중복 O)
- **ArrayList**   
	: 단방향 포인터 구조로 각 데이터에 대한 index를 가지고 있으며, 조회 기능에 성능이 뛰어남.
	하지만 데이터의 삽입/삭제가 빈번할 경우 비효율적
	(비어있는 index를 기준으로 뒷편의 데이터들을 복사하여 앞으로 밀어주는 작업이 필요하기 때문)
- **LinkedList**    
	: 양방향 포인터 구조로, 데이터의 삽입/삭제가 빈번할 경우 유용함(데이터의 위치 정보만 수정하면 되기 때문)
	스택/큐/양방향 큐 등을 만들기 위한 용도로 사용. 검색은 ArrayList에 비해 비효율적
- **Stack**    
	: 한 쪽 끝에서만 자료를 넣고 뺄 수 있는 LIFO 형식의 자료구조. 
- **Vector**    
	: 동적 크기 배열, 배열과 마찬가지로 index로 배열에 접근 가능하며, 
	동기화(Thread Safe) 되어있어, 한 번에 하나의 쓰레드만 벡터의 메소드를 호출할 수 있음.
	멀티 쓰레드 환경이 아닌 경우 ArrayList를 사용하는 것이 성능 면에서 바람직할 수 있음.
 
### 📚 Set Interface (순서 X, 데이터 중복 X)
- **HashSet** 
	: 해시 알고리즘을 사용한 가장 빠른 임의 접근 속도를 가지며, 순서를 예측 할 수 없음. 
	저장 순서를 유지하고자 한다면 LinkedHashSet을 사용할 수 있다.
- **TreeSet** 
	: 이진 검색 트리(BST) 형태로 데이터를 저장하는 컬렉션 클래스. 저장 순서를 유지하지 않음
	검색에 뛰어난 성능을 보이며, BST의 성능을 향상시킨 레드-블랙 트리로 구현되어 있음.

### 🗺️ Map Interface (순서 △, 데이터 중복 △)
- **HashMap** 
	: 중복과 순서가 허용되지 않으며 Value에 null값 저장 가능
- **TreeMap** 
	: 키 값이 자연 순서 대로 오름차순 정렬되어 Key-Value 쌍으로 저장 됨. 
	정렬되었기 때문에 검색이 빠름
- **HashTable** 
	: HashMap보다는 느리지만 동기화를 지원하며, HashMap과 달리 Value에 null을 허용하지 않음.
